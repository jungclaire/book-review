## Chapter 17. 냄새와 휴리스틱: 클린코드 규칙들 총정리

### 1. 철학
#### 나쁜 코드가 나쁜 이유  

<img width="279" alt="스크린샷 2021-11-28 오후 11 11 33" src="https://user-images.githubusercontent.com/83348294/143771474-599ed8f1-1b21-4449-8ab3-f3c9f2cc409f.png">  

#### 생산성 저하  
- 나쁜 코드는 팀 생산성을 저하시킨다.  
- 기술부채를 만들어 수정을 더 어렵게 한다.

#### 클린 코드
- 성능이 좋은 코드
- 의미가 명확한 코드 = 가독성이 좋은 코드
- 중복이 제거된 코드

생산성 상승!

#### 창발적 설계 4번째 규칙: 실용적 관점에서 타협한다.
과도한 설계 NO!
- 여러가지 규칙에 극단적으로 심취해 클래스와 메서드를 무수하게 만들지 말라.
- 결국 좋은 코드를 만드는 이유는 생산성을 올리기 위한 것이다.
- 실용적인 관점에서 타협해야 한다.  
  
"개집 짓는데 사람 집 지으면 안된다."

#### 보이스카우트 룰
"전보다 더 깨끗한 코드로 만든다."

### 2. 공동 창작 매너
함께 코드를 공동 창작하고 소비하는 나와 동료 개발자들을 위한 매너  
  
Team Coding Convention - 팀의 코딩 스타일에 관한 약속  
  
우리 팀의 컨벤션이 가장 중요하다!  

### 3. 객체 지향 패턴

#### 캡슐화 (Encapsulation)
객체의 실제 구현을 외부로부터 감추는 방식
<img width="387" alt="스크린샷 2021-11-28 오후 11 17 57" src="https://user-images.githubusercontent.com/83348294/143771706-1b792be2-b54f-4ee1-b1c6-eb6b212d4638.png">

#### 외부 코드와 호환하기 - Adapter 패턴
외부 코드를 호출할 때, 우리가 정의한 인터페이스 대로 호출하기 위해 사용하는 패턴
<img width="248" alt="스크린샷 2021-11-28 오후 11 18 34" src="https://user-images.githubusercontent.com/83348294/143771726-551947cb-0652-42e8-9691-d30b4249ad01.png">

#### 높은 결합도, 낮은 응집도
<img width="343" alt="스크린샷 2021-11-28 오후 11 18 55" src="https://user-images.githubusercontent.com/83348294/143771745-0de0554f-7abb-4099-90ac-ed4dd678b024.png">

#### SOLID 원칙
객체지향 설계의 5가지 원칙
<img width="220" alt="스크린샷 2021-11-28 오후 11 19 18" src="https://user-images.githubusercontent.com/83348294/143771769-8d4403f5-c6db-453d-8094-e7c4b3ad50fe.png">
- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존성 역전 원칙

#### SRP(단일 책임 원칙)
한 클래스는 하나의 책임만 가져야 한다.
<img width="271" alt="스크린샷 2021-11-28 오후 11 20 15" src="https://user-images.githubusercontent.com/83348294/143771801-76f936d2-1e82-46c2-89f1-559484a31dd2.png">
- 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.
- 가독성 향상과 유지보수가 용이해진다.
- 실전에서는 쉽지 않지만 늘 상기해야 한다!

#### OCP(개방-폐쇄 원칙)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
<img width="292" alt="스크린샷 2021-11-28 오후 11 21 28" src="https://user-images.githubusercontent.com/83348294/143771866-a9233552-4bcb-4cd0-8a51-5e6d0f26747e.png">
- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다.
- 객체지향의 추상화와 다형성을 활용한다.

#### LSP(리스코프 치환 원칙)
서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.
<img width="243" alt="스크린샷 2021-11-28 오후 11 22 43" src="https://user-images.githubusercontent.com/83348294/143771920-aab91269-68e1-4416-a17e-3de87b5453d5.png">
- 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다.
- 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.
- 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.
- 합성(composition)을 이용할 수도 있다.

#### ISP(인터페이스 분리 원칙)
자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
<img width="300" alt="스크린샷 2021-11-28 오후 11 23 54" src="https://user-images.githubusercontent.com/83348294/143771958-00fa1298-33ff-434a-9cc2-24628857953d.png">
- 가능한 최소한의 인터페이스만 구현한다.
- 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다.
- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임

#### DIP(의존성 역전 원칙)
상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.  
추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.
<img width="308" alt="스크린샷 2021-11-28 오후 11 26 09" src="https://user-images.githubusercontent.com/83348294/143772055-4c4c75b2-48bb-42d6-aeae-70071baeea05.png">
- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.
- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다.

### 4. 오류 
